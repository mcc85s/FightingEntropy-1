<#___ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____ -- ____  
//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\   ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯   //¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//         [ Secure Digits Plus LLC | "Fighting Entropy" ]          \\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯       _____________________________________________________        ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯        __/¯¯\__[ Dynamically Engineered Digital Security ]__/¯¯\__         ¯¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\  _________________________ ________________ ___________________________________  //¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
\\__//¯¯\\__//¯¯\\__//¯¯\\__// | Application Development | Virtualization | Network and Hardware Magistration | \\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\  ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯  //¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
\\__//¯¯\\__//¯¯\\__//¯¯\\__//                        https://www.securedigitsplus.com                          \\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\___                     ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯                       ___//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\   [ Provisional Author : Michael C Cook Sr. | "The Buck Stops Here" ]    //¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__// 
//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//   ____    ____    ____    ____    ____    ____    ____    ____    ____   \\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\ 
\\__/====\__/----\__/====\__/----\__/====\__/----\__/====\__/----\__/====\__/----\__/====\__/----\__/====\__/----\__/====\__/----\__/====\__/----\__// 
//¯¯    
\\  [ FightingEntropy ] @: A module meant to kick the crap out of entropy, AND identity theft. Like a ninja. Might sound intense..? Cause it is.
//   ____    ____    ____    ____    ____    ____    ____    ____    ____    ____    ____    ____    ____    ____    ____    ____    ____    ____      
\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\___  
//¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯\\ #>
    Class FEModule # // Module Provisioning (Installs Module/Validates Existence)
    {
        [String] $Name               = "FightingEntropy"
        [String] $Version            = "2020.08.0"
        [String] $Provider           = "Secure Digits Plus LLC"
        [String] $Registry           = "HKLM:\SOFTWARE\Policies\{0}\{1}\{2}"
        [String] $Path               = "$Env:ProgramData\{0}\{1}\{2}"
        [Object] $Content

        Hidden [String[]] $Folders   = "Control","Graphics","Network"
        Hidden [String[]] $Files     = "FightingEntropy.ps1","FightingEntropy.psm1"

        FEModule()
        {
            $This.Registry           = $This.Registry -f $This.Provider, $This.Name, $This.Version
            $This.Path               = $This.Path     -f $This.Provider, $This.Name, $This.Version
        
            If ( ! ( Test-Path $This.Registry ) )
            {
                ForEach ( $I in 3..5 ) 
                { 
                    $This.Registry.Split('\')[0..$I] -join '\' | ? { ! ( Test-Path $_ ) } | % { New-Item $_ -Verbose }
                }
            }

            If ( ! ( Test-Path $This.Path ) )
            {
                New-Item -Path $This.Path -ItemType Directory -Verbose
            }

            $This.Folders            | % { "{0}\$_" -f $This.Path } | ? { ! ( Test-Path $_ ) } | % { New-Item -Path $_ -ItemType Directory -Verbose }

            $This.Content            = Get-ChildItem $This.Path
        }
    }

    Class FERoot # // Folder for installation and database, accesses Registry for forward info
    {
        [String] $Name
        [String] $Date
        [String] $Path
        [Object] $Share

        FERoot([String]$Name,[String]$Path)
        {
            $This.Name = $Name
            $This.Date = Get-Date #-UFormat "%Y_%m%d-%H%M%S"
            $This.Path = $Path

            "Name Date Path Share".Split(" ") | % { Set-ItemProperty -Path $This.Root -Name $_ -Value $This.$_ -Verbose }
        }
    }

    Class FEShare # // Creates an MDT/FE Share for MDT/FE Deployments
    {
        [String] $Name          = "FE001"
        [String] $PSProvider
        [String] $Root
        [String] $Description   = $Null
        [String] $NetworkPath
        [Object] $Company       = [FECompany]::New()
        Hidden [String[]] $Names
        Hidden [String[]] $Roots

        FEShare([String]$Name,[String]$Root,[String]$Description,[String]$NetworkPath)
        {
            If ( Test-Path $Root )
            {
                Throw "Path exists"
            }

            Else
            {
                $This.Root = $Root
            }

            If ( Get-SMBShare | ? { $_.Name -eq $Name -or $_.Path -eq $Root } )
            {
                Throw "Share exists"
            }

            If ( ( GP "HKLM:\Software\Microsoft\Deployment 4" ) -eq $Null )
            {
                Throw "Microsoft Deployment Toolkit is not installed"
            }

            Import-Module ( ( GCI ( GP "HKLM:\Software\Microsoft\Deployment 4" ).Install_Dir "*Toolkit.psd1" -Recurse ).FullName ) -Verbose
                
            $This.Names        = ( Get-MDTPersistentDrive ).Name
            $This.Roots        = ( Get-MDTPersistentDrive ).Path

            If ( $Name -in $This.Names -or $Root -in $This.Roots )
            {
                Throw "MDT/FE Share exists"
            }

            If ( $This.Names -ne $Null )
            {
                $This.Name     = $This.Names | % { @($_,$_[-1])[[Int32]($_.Count -gt 1)].Replace("DS","") } | % { "FE{0:d3}" -f ( [Int32]$_ + 1 ) }
            }

            $This.PSProvider   = "MDTProvider" 
            $This.Root         = $Root
            $This.Description  = If ( $Description -ne $Null ) { $Description }
            $This.NetworkPath  = $NetworkPath

            @{  
                Path           = $Root
                ItemType       = "Directory"      
            
            }                  | % { New-Item @_ -Verbose }

            @{  
                Name           = $Name
                Path           = $Root 
                FullAccess     = "Administrators" 
            
            }                  | % { New-SMBShare @_ -Verbose }

            @{  
                Name           = $This.Name 
                PSProvider     = $This.PSProvider
                Root           = $This.Root
                Description    = $This.Description
                NetworkPath    = $This.NetworkPath
                Verbose        = $True  

            } | % { New-PSDrive @_ | add-MDTPersistentDrive -Verbose }
        }
    }

    Class FECompany # // Object for Company information needed to fulfill post install/branding
    {
        [String] $Name
        [String] $Branch
        [String] $Background
        [String] $Logo
        [String] $Phone
        [String] $Website
        [String] $Hours

        FECompany() {}

        Load([String]$Name,[String]$Branch,[String]$Background,[String]$Logo,[String]$Phone,[String]$Website,[String]$Hours)
        { 
            $This.Name       = $Name
            $This.Branch     = $Branch
            $This.Background = $Background
            $This.Logo       = $Logo
            $This.Phone      = $Phone
            $This.Website    = $Website
            $This.Hours      = $Hours
        }
    }

    # $FE                      = [FEModule]::New()
    # $FE.Share               += [FEShare]::New("FETest[1]$","C:\FETest[1]","Testing MDT/FE Install","\\DSC0\FETest[1]$")
    # $FE.Share.Company.Load("Secure Digits Plus LLC","Clifton Park","OEMbg.jpg","OEMlogo.bmp","518-406-8569","securedigitsplus.com","24h/d;7d/w;365.25d/y;") 

    Function Remove-FEShare
    {
        [CmdLetBinding()]Param(
            
            [Parameter(Mandatory,Position=0)][String]$Name,
            [Parameter(Mandatory,Position=1)][String]$Path
        )

        Import-Module ( ( GCI ( GP "HKLM:\Software\Microsoft\Deployment 4" ).Install_Dir "*Toolkit.psd1" -Recurse ).FullName )

        Get-SMBShare           | ? { $_.Name -eq $Name -and $_.Path -eq $Path } | Remove-SMBShare -Force -EA 0
        Get-MDTPersistentDrive | ? { $_.Path -eq $Path } | % { Remove-MDTPersistentDrive -Name $_.Name -VB -EA 0 }
        Remove-Item -Path $Path                                            -Recurse -Force -EA 0
        Remove-Item -Path "HKLM:\SOFTWARE\Policies\Secure Digits Plus LLC" -Recurse -Force -EA 0
    }

<#
\\ [Write-Theme]:v2
// 
\\      08/13/2020 - Essentially complete. Yet to add -Free & -Foot
//      08/01/2020 - Cleaning up function output
\\      07/31/2020 - Uploaded a video of a working version
//      07/27/2020 - Theme is coming out clean, input handling about ready to roll. Pipelining also working.
\\      07/22/2020 - Current Update, Classes outputting Needs additional mod on string/face expansion
//      07/14/2020 - Last Update(sure)
\\      07/12/2020 - Header/Body/Footer Message Interpolation and Theme Color now working *faster*, with 5% of the original code
//      07/08/2020 - Message Scaffolding is ready, still tweaking theme arrangement
\\      07/04/2020 - Still Editing, starting to edit the art
//      05/18/2020 - Injured my hand, taking a month off
\\ <    05/18/2020 - Kept it pretty real
//
\\___                                                                                    ____    ____    ____    ____    ____    ____    ____    ___// 
 ¯¯¯\\__________________________________________________________________________________//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯\\__//¯¯¯  
     ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    ¯¯¯¯    #>
     Function Write-Theme 
     {
         [CmdLetBinding()] Param(
                 
            [Parameter(Mandatory,Position=0)][Object]$InputObject,
            [Parameter(Position=1)][Int32[]]$Palette = @(10,12,15,0)
         )
  
         Class Block
         {#  // Use to fulfill the Write-Host object needs 
             [Int32]            $Index
             [String]          $Object
             [Int32]  $ForegroundColor
             [Int32]  $BackgroundColor
  
             Block([Int32]$Index,[String]$Object,[Int32]$ForegroundColor,[Int32]$BackgroundColor)
             {
                 $This.Index             = $Index
                 $This.Object            = $Object
                 $This.ForegroundColor   = $ForegroundColor
                 $This.BackgroundColor   = $BackgroundColor
             }
         }
  
         Class Track
         {#  // Use to stack entire lines of blocks, or instantiate a mask.
             [Int32]           $Index
             [Array]           $Object
  
             Hidden [String]   $Header
             Hidden [Array]    $Body
             Hidden [String]   $Footer
  
             Hidden [String[]] $Strings
             Hidden [Int32[]]  $Masks
             Hidden [Int32[]]  $Foregrounds
             Hidden [Int32[]]  $Backgrounds
  
             Hidden [String]   $String
             Hidden [Int32]    $Segments
             Hidden [Object]   $Track
             Hidden [Array]    $Swap
  
             Track(){}
              
             Track([Int32]$Index,[String]$Mask,[String]$Foreground,[String]$Background)
             {
                 $This.Index                = $Index
                 $This.Masks                = IEX $Mask
                 $This.Strings              = @("    ,____,¯¯¯¯,----,   /,\   ,   \,/   ,\__/,/¯¯\,/¯¯¯,¯¯¯\,\___,___/,[ __,__ ]" -Split ",")[$This.Masks]
                 $This.Foregrounds          = IEX $Foreground
                 $This.Backgrounds          = IEX $Background
                  
                 $This.Object               = @( )
  
                 ForEach ( $I in 0..( $This.Masks.Count - 1 ) )
                 {
                     $This.Object          += [Block]::New($I,$This.Strings[$I],$This.Foregrounds[$I],$This.Backgrounds[$I])
                 }
             }
  
             Load([String]$String)
             {
                 If ( !$String ) 
                 { 
                     Throw "String/Track is null" 
                 }
  
                 $This.String = $String
  
                 If ( $String.Length % 4 -ne 0 )
                 {
                     $This.String           = "[ $String{0} ]" -f ( " " * ( 4 - ( $String.Length % 4 ) ) )
                 }
  
                 $This.Segments             = $This.String.Length / 4
                  
                 If ( $This.Segments -gt 23 ) 
                 { 
                     Throw "Input string too long" 
                 } 
  
                 $This.Object[3..25]        | % { $_.Object = "    " ; $_.ForegroundColor = 0 }
                 $This.Swap                 = @( )
                  
                 ForEach ( $I in 0..( $This.Segments - 1 ) )
                 {     
                     $This.Swap            += [Block]::New( $I,($This.String[($I*4)..(($I*4)+3)] -join '' ), 2, 0) 
                 }
  
                 ForEach ( $Z in 0..( $This.Swap.Count -  1 ) )
                 {
                     $This.Swap[$Z]         | % { $_.Index = $_.Index + 3 }
                     $This.Object[$Z+3]     = $This.Swap[$Z]
                 }
             }
         }
  
         Class Mask
         {#  // Loads the corresponding mask and it's (X/Y) location
             [Int32]     $Index
             [Int32]     $Span
             [String]    $Mask
             [String]    $Foreground
             [String]    $Background
  
             Mask([Int32]$Index,[Int32]$Span,[String]$Mask,[String]$Foreground,[String]$Background)
             {
                 $This.Index                = $Index
                 $This.Span                 = $Span
                 $This.Mask                 = $Mask
                 $This.Foreground           = $Foreground
                 $This.Background           = $Background
             }
         }
  
         Class Stock
         {#  // Default 'Model' used to control (console/host) object output
             Hidden [Object]  $Object
             [String]           $Name
             [Int32]            $Slot
  
             Hidden [Int32]     $Head
             Hidden [Int32]     $Main
             Hidden [Int32]     $Foot
  
             [String]         $Header
             [Array]            $Body
             [String]         $Footer
  
             Hidden [String[]] $Names  = @("Function","Action","Section","Table","Test")
             Hidden [Array]    $Theme 
  
             Hidden [Int32[]]   $Span 
             [Int32]          $Height 
  
             Hidden [Hashtable] $Hash  = @{ 
                  # // Hashtable that has default theme settings.
                 Head                  =  3, 2, 3, 3, 3
                 Main                  = -1,-1, 6,-1,-1
                 Foot                  = -1,-1,11,-1,-1
                 Colors                = $Palette
                 Faces                 = @("    ,____,¯¯¯¯,----,   /,\   ,   \,/   ,\__/,/¯¯\,/¯¯¯,¯¯¯\,\___,___/,[ __,__ ]" -Split ",")
  
                 String                = ("0;1;@(0)*25;1;1;0!4;9;12;@(1)*23;13;9;8;7!6;8;10;@(2)*23;11;8;10;0!0;11;12;14;@(1)*21;15;13;10;0;0!0;0;@(2)*25;0;0;0"+
                                         "!0;1;0;@(1)*25;0;0!4;9;8;10;@(2)*23;11;12;0!6;8;10;14;@(1)*21;15;0;13;9;5!0;11;12;@(1)*23;13;9;8;7!0;0;@(2)*25;0;2;0!"+
                                         "6;8;10;@(2)*23;11;8;9;5!4;9;12;14;@(1)*21;15;13;9;8;7!6;8;10;@(2)*24;0;11;5!4;10;@(0)*26;4;7!6;5;@(0)*26;6;5!4;7;@(0)"+
                                         "*26;13;7!6;12;@(0)*25;13;9;5!4;9;12;@(1)*23;13;10;13;7").Split("!") | % { "@($_)" } 
          
                 Fore                  = ("@(0)*30!0;1;@(0)*25;1;1;0!0;1;@(1)*25;1;0;0!0;0;1;@(2)*23;1;0;0;0!@(0)*30!@(0)*30!0;1;0;@(1)*25;0;0!0;1;1;@(2)*23;1;"+
                                         "1;1;0!0;0;@(1)*25;0;1;0!@(0)*30!0;@(1)*28;0!0;1;1;@(2)*23;1;0;1;0!0;1;@(0)*26;0;0!@(0)*30!@(0)*30!@(0)*30!@(0)*28;1;0"+
                                         "!0;1;@(0)*25;1;1;0").Split("!") | % { "@($_)" } 
  
                 Back                   = 0..17 | % { "@({0})" -f ( @(0)*30 -join ',' ) }
                 Span                   = @{ 0 = 0..4; 1 = 5..9; 2 = @( 0..1;10..17;2..4 ); 3 = $Null; 4 = $Null }
             }
  
             [Hashtable]         $Process
             [Hashtable]          $Output      
  
             Stock([Object]$Object)
             {#  // Starts stocking up on goods
 
                 $This.Object          = $Object
                 If ( !$This.Object )  { Throw "Object is null" }
 
                 $This.Slot            = If ( $This.Object.Count -eq 1 ) { If ( $This.Object -match "\[\:\]" ) {0} Else {1}} Else {2}
                 $This.Name            = $This.Names[$This.Slot]
  
                 # // Pulls the theme info from the hashtable
                 $This.Hash            | % { 
  
                     $This.Head        = $_.Head[$This.Slot]
                     $This.Main        = $_.Main[$This.Slot]
                     $This.Foot        = $_.Foot[$This.Slot]
                     $This.Span        = $_.Span[$This.Slot]
                 }
   
                 # // Flatten the input
                 $This.Body           = @(
                      
                     If ( $This.Object.Count -gt 1 )
                     {
                         ForEach ( $I in 0..( $This.Object.Count - 1 ) )
                         {
                             $Item = $This.Object[$I].GetType().Name
 
                             If ( $Item -eq "String" )
                             {
                                 $This.Line($This.Object[$I])
                             }
     
                             Else
                             {
                                 $This.Line( "-" * 84 )
 
                                 If ( $Item -eq "Hashtable" ) 
                                 {
                                     $This.Object[$I].GetEnumerator() | Sort-Object Name | % { $This.Pair( $_.Name, $_.Value ) }
                                 }
                                 
                                 Else
                                 {
                                     $Named = $This.Object[$I] | Get-Member | ? { $_.MemberType -eq "Property" } | % { $_.Name } 
                                     
                                     ForEach ( $N in $Named )
                                     { 
                                         $This.Pair( $N, $This.Object[$I].$($N) ) 
                                     }
                                 }
                             }
                         }
                     }
  
                     If ( $This.Object.Count -eq 1 )
                     {
                         $Item = $This.Object.GetType().Name
                         
                         If ( $Item -eq "String" )
                         {
                             $This.Line($This.Object)
                         }
 
                         Else
                         {
                             If ( $Item -eq "Hashtable" )
                             {
                                 $This.Object.GetEnumerator() | Sort-Object Name | % { $This.Pair( $_.Name, $_.Value ) }
                             }
 
                             Else
                             {
                                 $Named = $This.Object | Get-Member | ? { $_.MemberType -eq "Property" } | % { $_.Name } 
                                 
                                 ForEach ( $N in $Named )
                                 { 
                                     $This.Pair( $N, $This.Object.$($N) )
                                 }
                             }
                         }
                     }
                 )
  
                 # // New array for temp vector/mask/layers
                 $This.Theme           = @( )
                 ForEach ( $I in 0..( $This.Span.Count - 1 ) )
                 {#  // Instantiate theme mask
                     $X                = $This.Span[$I]
                     $This.Theme      += [Mask]::New( $I , $X , $This.Hash.String[$X], $This.Hash.Fore[$X], $This.Hash.Back[$X] )
                 }
  
                 # // Assign Defaults for (Function/Action)
                 If ( $This.Slot -in 0,1 )
                 {
                     $This.Header      = $This.Body
                     $This.Height      = 5
                 }
                   # // Assign Defaults for (Section)
                 If ( $This.Slot -eq 2 )
                 {
                     $This.Header      = "Section"
                     $This.Footer      = "Press Enter to Continue"
                     $This.Height      = ( $This.Body.Count + $This.Span.Count ) - 1
                 }
   
                 # // New array for temp theme stack
                 $This.Process         = @{ }
                 $Sort                 = $This.Head, $This.Main, $This.Foot
                 $P                    = 0
   
                 ForEach ( $I in 0..( $This.Theme.Count - 1 ) )
                 {#  // Create [Block[]]/[Track]
                     $Item = [Track]::New($I,$This.Theme[$I].Mask,$This.Theme[$I].Foreground,$This.Theme[$I].Background)
   
                     If ( $I -eq $This.Head )
                     {
                         $Item.Load($This.Header)
                         $This.Process.Add($P,$Item)
                         $P ++
                     }
   
                     If ( $I -eq $This.Foot )
                     {
                         $Item.Load($This.Footer)
                         $This.Process.Add($P,$Item)
                         $P ++
                     }
   
                     If ( $I -eq $This.Main )
                     {
                         ForEach ( $Z in 0..( $This.Body.Count - 1 ) )
                         {
                             $Item = [Track]::New($I,$This.Theme[$I].Mask,$This.Theme[$I].Foreground,$This.Theme[$I].Background)
   
                             ForEach ( $Q in 0,1,-2,-1)
                             {
                                 $Item.Object[$Q] | % { $_.Object = $_.Object.Replace( @("/","\")[$Z % 2], @("\","/")[$Z % 2]) }
                             }
   
                             $Item.Load($This.Body[$Z])
                             $This.Process.Add($P,$Item)
                             $P ++
                         }
  
                         If ( $This.Body.Count -gt 1 -and $This.Body.Count % 2 -eq 0 )
                         {
                             $Item = [Track]::New($I,$This.Theme[$I].Mask,$This.Theme[$I].Foreground,$This.Theme[$I].Background)
                             $This.Process.Add($P,$Item)
                             $P ++
                         }
                     }
   
                     If ( $I -notin $Sort )
                     {
                         $Item = [Track]::New($I,$This.Theme[$I].Mask,$This.Theme[$I].Foreground,$This.Theme[$I].Background)
                         $This.Process.Add($P,$Item)
                         $P ++
                     }
                 }
             }
   
             [String] Line([String]$Line)
             {
                 Return @{          0  = "{0}{1}" -f    $Line, ( " " * (92 -  $Line.Length))
                                    1  = "{0}..." -f (  $Line[0..88] -join '') }[[Int]($Line.Length -ge 89)]
             }
               
             [String] Pair([String]$Key,[String]$Value)
             {
                 Return @{   0 = @{ 0  = "{0}{1}" -f    $Key,( " " * ( 25 -   $Key.Length ) ) 
                                    1  = "{0}..." -f   ($Key[0..21] -join '')}[[Int]($Key.Length -ge 25)]
                             1 = @{ 0  = "{0}{1}" -f  $Value,( " " * ( 64 - $Value.Length ) )
                                    1  = "{0}..." -f ($Value[0..60] -join '' ) }[[Int]($Value.Length -ge 64)] } | % { "{0} : {1}" -f $_[0,1] }
             }
   
             [Void] Draw([Object]$Object)
             {
                 ForEach ( $I in 0..( $Object.Count - 1 ) )
                 {
                     $Track          = $Object[$I].Object
               
                     ForEach ( $X in 0..( $Track.Count - 1 ) )
                     { 
                         @{  
                             Object          = $Track[$X].Object
                             ForegroundColor = @($This.Hash.Colors)[$Track[$X].ForegroundColor]
                             BackgroundColor = $Track[$X].BackgroundColor
                             NoNewLine       = [Bool]( $X -ne ( $Track.Count - 1 ) )
                         }                       | % { Write-Host @_ }
                     }
                 }
             }
         }
   
         $Model = [Stock]::New($InputObject)
         $Model.Draw($Model.Process)
     }
    # Remove-FEShare -Name "FETest[1]$" -Path "C:\FETest[1]"